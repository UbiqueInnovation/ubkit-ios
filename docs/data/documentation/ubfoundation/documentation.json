{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Localization","level":2,"type":"heading","text":"Localization"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The localization module is a wrapper around Apple’s Bundle system and Local. It gives the caller control over the language and let it be specified at runtime. "},{"type":"codeVoice","code":"UBFoundation"},{"type":"text","text":" comes with a "},{"type":"codeVoice","code":"Localization"},{"type":"text","text":" object. Most formatters also accept a "},{"type":"codeVoice","code":"Localization"},{"type":"text","text":" object as initialization argument."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You can localize your strings by using the extension property "},{"type":"codeVoice","code":"localized"},{"type":"text","text":" directly on a key."}]}]}]},{"type":"codeListing","syntax":"swift","code":["headerLabel.text = \"balance_header_label\".localized"]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"NB: To react to language changes you can observe one of the two "},{"type":"codeVoice","code":"LocalizationNotification"},{"type":"text","text":" notifications name on the default notification center."}]}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You can access the current "},{"type":"codeVoice","code":"Localization"},{"type":"text","text":" object by calling "},{"type":"codeVoice","code":"UBFoundation.AppLocalization"}]}]}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Creating a date picker with the correct locale","","let datePicker = UIDatePicker(frame: .zero)","datePicker.locale = UBFoundation.AppLocalization.locale","","\/\/ Fetching a file from the localized bundle ","","let aboutHTMLFilePath = AppLocalization.localizedBundle?.path(forResource: \"about\", ofType: \"html\")","self.webview.load(aboutHTMLFilePath)"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To get all the available languages that app offers:"}]}]}]},{"type":"codeListing","syntax":"swift","code":["let allLanguages = Localization.availableLanguages()","print(allLanguages.map({ $0.displayNameInNativeLanguage }))"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To change the language:"}]}]}]},{"type":"codeListing","syntax":"swift","code":["try UBFoundation.setLanguage(languageCode: \"en\", regionCode: \"CH\")"]},{"anchor":"Logging","level":2,"type":"heading","text":"Logging"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Logging is a wrapper module around Appel’s unifide log API. It provides on top of the normal logging a set of useful control, like the log level and privacy."},{"type":"text","text":" "},{"type":"text","text":"The logging module is thread safe."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We recommend that you creat a logger and have it accessible from all the app to make logging easier."},{"type":"text","text":" "},{"type":"text","text":"You can delare many loggers with different categories to refine more the logs. But most apps will be fine with one."},{"type":"text","text":" "},{"type":"text","text":"The logs can be seen in the xCode console if you are debugging the app, otherwise they will show up in the Console app."},{"type":"text","text":" "},{"type":"text","text":"A nice place to store all you loggers is in a separate file, where you can declare static let property in the global scope."}]}],"type":"aside","name":"Note"},{"type":"codeListing","syntax":"swift","code":["\/\/ File: Logging.swift","","let logger: Logger? = {","    return try? Logger(category: \"MyApp\")","}()",""]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To create a logger and start logging you can"}]}]}]},{"type":"codeListing","syntax":"swift","code":["do {","    let logger = try Logger(category: \"Database\")","    logger.setLogLevel(.default)","    \/\/ You can save a reference for the logger for further use","    try database.open()","    logger.debug(\"Connection to DB successfully open\", accessLevel: .public)","    try database.save(age: person.age, person: person)","    logger.info(\"Saved age \\(person.age) to contact \\(person.name)\", accessLevel: .private)","    database.close()","    logger.debug(\"Connection to DB closed\", accessLevel: .public)","} catch {","    logger.error(\"An error occurred while accessing the database \\(error.localizedDescription)\", accessLevel: .public)","}"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Setting the framework log Level"},{"type":"text","text":" "},{"type":"text","text":"In case you want to change the log level of the framewotk you can do so by calling"}]}]}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Turn off all framework logging","UBFoundation.Logging.setGlobalLogLevel(.none)"]},{"anchor":"Networking","level":2,"type":"heading","text":"Networking"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Networking offers wrappers around the default iOS URLSession to make it safer and easier to use. Mainly you will be using the "},{"type":"codeVoice","code":"HTTPDataTask"},{"type":"text","text":" class, in combination with the "},{"type":"codeVoice","code":"HTTPURLRequest"},{"type":"text","text":" to achieve network requests and load data."}]},{"anchor":"Loading-a-resource-encoded-in-JSON","level":3,"type":"heading","text":"Loading a resource encoded in JSON"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The Networking module offers a variaty of "},{"type":"codeVoice","code":"HTTPDataDecoder"},{"type":"text","text":" for decoding JSON or String but you can also create you own. Otherwise you can access the Data directly."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Create a Data Task","let url = URL(string: \"http:\/\/example.com\/books\")!","let request = HTTPURLRequest(url: url)","\/\/ We should hold a strong reference to the task otherwise it gets deallocated","self.task = HTTPDataTask(request: request)","self.task.addCompletionHandler(decoder: HTTPJSONDecoder<Books>()) { (result, _) in","    switch result{","    case .success(let books):","        \/\/ Make something useful with the data","        break","    case .failure(let error):","        \/\/ Show the error for the user","        break","    }","}","self.task.start()"]},{"anchor":"Loading-resources-synchronously","level":3,"type":"heading","text":"Loading resources synchronously"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can run the "},{"type":"codeVoice","code":"HTTDataTask"},{"type":"text","text":" synchronously and block the current thread waiting for a response. You will get back a result tuple with all the info similar to calling it asynchronously."}]},{"type":"codeListing","syntax":"swift","code":["let response = self.task.startSynchronously(decoder: HTTPJSONDecoder<Books>())"]},{"anchor":"Modifying-the-request","level":3,"type":"heading","text":"Modifying the request"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Sometime we need to modify the request everytime before it is executed. That’s where the "},{"type":"codeVoice","code":"HTTPRequestModifier"},{"type":"text","text":" comes in play. With the standard implementation you can add Basic authorization, Accepted language or add you own custom modifier."}]},{"type":"codeListing","syntax":"swift","code":["self.task.addRequestModifier(HTTPRequestBasicAuthorization(login: \"login\", password: \"password\"))"]},{"anchor":"Tracking-progress","level":3,"type":"heading","text":"Tracking progress"},{"type":"paragraph","inlineContent":[{"type":"text","text":"On some lengthy tasks showing the progress to the user is a good idea."}]},{"type":"codeListing","syntax":"swift","code":["self.task.addProgressObserver { (_, progress) in","    progressBar.progress = progress","}"]},{"anchor":"Monitoring-state","level":3,"type":"heading","text":"Monitoring state"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can monitor the state of the task and adapt the UI accordingly"}]},{"type":"codeListing","syntax":"swift","code":["self.task.addStateTransitionObserver { (_, new) in","    switch new {","    case .waitingExecution, .fetching:","        activityIndicator.startAnimating()","    default:","        activityIndicator.stopAnimating()","    }","}"]},{"anchor":"Validation","level":3,"type":"heading","text":"Validation"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can add validators to be executed after the response is received and check if we proceed to decode the data. Errors thrown will be available in the completion handler block."}]},{"type":"codeListing","syntax":"swift","code":["self.task.addResponseValidator(HTTPResponseStatusValidator(.ok))"]},{"anchor":"Failure-Recovery","level":3,"type":"heading","text":"Failure Recovery"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Each data task offers a way to add logic to recover from failures. A "},{"type":"codeVoice","code":"NetworkingTaskRecoveryStrategy"},{"type":"text","text":" gets called after the data task fails and not in case of a success. You can conform to this protocol and create your own recovery strategies and chose to not recover, recover and pass data\/response, fail but offer recovery option or finally recover and request a restart of the task."}]},{"type":"codeListing","syntax":"swift","code":["let recovery = NoNetworkFailureRecovery()","dataTask.addFailureRecoveryStrategy(recovery)"]},{"anchor":"Certificate-Pinning","level":3,"type":"heading","text":"Certificate Pinning"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For better security it is recommended to pin the certificates of the backend. You can do so by including the certificate (.CER or .DER) files in the app bundle and make sure to copy them. Then you can use the "},{"type":"codeVoice","code":"PinnedCertificatesTrustEvaluator"},{"type":"text","text":" object to introduce the pinning. Each "},{"type":"codeVoice","code":"UBURLSession"},{"type":"text","text":" can be configured by a "},{"type":"codeVoice","code":"UBURLSessionConfiguration"},{"type":"text","text":" that accept a trust evaluator per host. For example:"}]},{"type":"codeListing","syntax":"swift","code":["let url = URL(string: \"https:\/\/www.ubique.ch\")!","let evaluator = PinnedCertificatesTrustEvaluator(certificates: testBundle.certificates)","let configuration = UBURLSessionConfiguration(hostsServerTrusts: [\"www.ubique.ch\": evaluator])","let session = UBURLSession(configuration: configuration)","let dataTask = UBURLDataTask(url: url, session: session)"]},{"anchor":"Network-Activity","level":3,"type":"heading","text":"Network Activity"},{"type":"paragraph","inlineContent":[{"type":"text","text":"It is important to show feedback to users when a network activity is running. There for the global methods available in "},{"type":"codeVoice","code":"Networking"},{"type":"text","text":" can help you add observers and adapt the UI accornigly. The callback will be fired each time the global network activity changes status (from idle to fetching or vis versa). Only the "},{"type":"codeVoice","code":"HTTPDataTask"},{"type":"text","text":" object created with the default session will be added automatically, otherwise you need to add them manually (more info in the "},{"type":"codeVoice","code":"Networking"},{"type":"text","text":" object)"}]},{"type":"codeListing","syntax":"swift","code":["Networking.addNetworkActivityStateObserver { (newState) in","    \/\/ Change UI accordingly","    UIApplication.shared.isNetworkActivityIndicatorVisible = (newState == .fetching)","}"]},{"anchor":"Modify-Caching","level":3,"type":"heading","text":"Modify Caching"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can create a modified Cache Logic to cache more data. Default should be to modify requests headers! Only use this if we don’t control the backend component."}]},{"type":"codeListing","syntax":"swift","code":["public class MapDataCacheLogic: UBAutoRefreshCacheLogic {","    static let session = UBURLSession(configuration: UBURLSessionConfiguration(cachingLogic: MapDataCacheLogic()))","","    override public func shouldWriteToCache(allowed _: Bool, data _: Data, response _: HTTPURLResponse) -> Bool {","        true","    }","","    override public func modifyCacheResult(proposed _: UBCacheResult, possible: UBCacheResult, reason _: UBBaseCachingLogic.CacheDecisionReason) -> UBCacheResult {","        return possible \/\/ use cached data forever","    }","}"]},{"anchor":"UIColor-from-HEX","level":2,"type":"heading","text":"UIColor from HEX"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you need to instanciate a color from a HEX value or you need to output a color as a HEX string you can use."}]},{"type":"codeListing","syntax":"swift","code":["let mainColor = UIColor(hexString: \"#FF00FF\")","print(mainColor?.hexString ?? \"No color\")"]},{"anchor":"Keyboard-Layout-Guide","level":2,"type":"heading","text":"Keyboard Layout Guide"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The keyboard layout guide of a view will represent the area of that view that is obstructed by the keyboard. Making constraints to the top of the keyboard layout guide ensures that the content is always visible when the keyboard shows"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ In app did launch call `initializeForKeyboardLayoutGuide()` on the root window","window?.initializeForKeyboardLayoutGuide()","\/\/ In the view or view controller","\/\/ Make sure that the input field is always above of the keyboard. Otherwise mapped to the bottom of the parent view.","inputField.bottomAnchor.constraint(equalTo: view.keyboardLayoutGuide.topAnchor).isActive = true"]},{"anchor":"Cron-Jobs","level":2,"type":"heading","text":"Cron Jobs"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"CronJob"},{"type":"text","text":" is a class that invoces a function at a specific point in time. It can repeat or not. If the deadline is passed and the code could not be executed due to app halt or sleep, then the function is invoked as soon as possible on system resume."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You should keep reference to the job object. If the job gets deallocated"}]}],"type":"aside","name":"Note"},{"type":"codeListing","syntax":"swift","code":["let job = CronJob(fireAt: date) {","    \/\/ The cron job to be executed","}"]},{"anchor":"UserDefaults-Property-Wrapper","level":2,"type":"heading","text":"UserDefaults Property Wrapper"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"UBUserDefault"},{"type":"text","text":" is a property wrapper which backs the annotated variable with storage in "},{"type":"codeVoice","code":"UserDefaults"},{"type":"text","text":". By default, the "},{"type":"codeVoice","code":"standard"},{"type":"text","text":" "},{"type":"codeVoice","code":"UserDefaults"},{"type":"text","text":" are used."}]},{"type":"codeListing","syntax":"swift","code":["@UBUserDefault(key: \"username_key\", defaultValue: \"\")","var userName: String"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For optional types without a default value, please set "},{"type":"codeVoice","code":"defaultValue"},{"type":"text","text":" to nil:"}]},{"type":"codeListing","syntax":"swift","code":["@UBUserDefault(key: \"maybeAnInteger\", defaultValue: nil)","var maybeAnInteger: Int?"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To store a variable of type "},{"type":"codeVoice","code":"T"},{"type":"text","text":" using these property wrappers, it needs to conform to "},{"type":"codeVoice","code":"UBUserDefaultValue"},{"type":"text","text":". Plist-Compatible values (instances or collections of Data, String, Number, Date, Array, or Dictionary) are supported out of the box."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To store "},{"type":"codeVoice","code":"Codable"},{"type":"text","text":" types such as "},{"type":"codeVoice","code":"struct User: Codable { ... }"},{"type":"text","text":", please conform to "},{"type":"codeVoice","code":"UBCodable"},{"type":"text","text":" instead of "},{"type":"codeVoice","code":"Codable"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["","struct User: UBCodable { ... }","","@UBUserDefault(key: \"user\", defaultValue: nil)","var loggedInUser: User?"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To store "},{"type":"codeVoice","code":"RawRepresentable"},{"type":"text","text":" types such as "},{"type":"codeVoice","code":"enum"},{"type":"text","text":"s, please conform to "},{"type":"codeVoice","code":"UBRawRepresentable"},{"type":"text","text":" instead of "},{"type":"codeVoice","code":"RawRepresentable"},{"type":"text","text":"."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/ubfoundation\/documentation"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/UBFoundation\/documentation\/UBFoundation\/Documentation","interfaceLanguage":"swift"},"kind":"article","metadata":{"roleHeading":"Article","title":"UBFoundation","role":"article","modules":[{"name":"UBFoundation"}]},"hierarchy":{"paths":[["doc:\/\/UBFoundation\/documentation\/UBFoundation"]]},"references":{"doc://UBFoundation/documentation/UBFoundation":{"role":"collection","title":"UBFoundation","abstract":[],"identifier":"doc:\/\/UBFoundation\/documentation\/UBFoundation","kind":"symbol","type":"topic","url":"\/documentation\/ubfoundation"}}}